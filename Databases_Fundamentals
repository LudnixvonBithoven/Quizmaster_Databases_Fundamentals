chapter1 = """database = is an organized collection of data, typically stored in electronic format. It allows you to input, organize, and retrieve data quickly. Traditional databases are organized by fields, records, and files.
database file = file --> list of records --> names, addresses, telephone numbers
query = Used for asking information from a database, retrieve data within a database.
index = A data structure that improves the speed of data retrieval operations on a database table. The disadvantage of indexes is that they need to be created and updated, which requires processing resources and takes up disk space.
database servers = Can be accessed by multiple users and provide a high level of performance.
.mdf file = Primary files.
.ndf file = A secondary data file that's created when the database become too large.
.ldf file = Log file, transaction log files use an .ldf extension, and doesn't contain objects such as tables or views.
user-defined objects = Tables and views, objects which you have created in a program or application.
DBMS = Database Management System, collection of programs that enables one to enter, organize and select data in a database.
types of databases = Flat-type, Hierachical, Relational databases. They have different design features.
Flat-type database = Simplistic design, plain-text format. Holds one record per line that makes access, performance and queries very quick. Common extensions that are used .txt or ini. They are considered flat because they are two-dimensional; rows and columns.
Columns = Each column can be referred to as a field.
Rows = Each row can be referred to as a record.
Hierarchical database = Similar to a tree structure, each parent table can have multiple children, but each child can only have one parent.
Relational databases = Similar to a hierarchical database, but a table in a relational database can have multiple parents.
spreadsheet = A simple database with one table is similar to a spreadsheet that contains rows and columns, but a database allows one to store thousands of rows of data that can be more quickly retrieved. A spreadsheet is loaded into the computer's memory.
database performance = They are designed to store billions of rows of data. They are limited to the computer’s available hard disk space. They are optimized to use all a computer’s available memory to improve performance.
SQL server = Periodically analyze queries and create index as needed to optimize performance
Constraints = Limitations or rules place on a field or column to ensure that data that is considered invalid is not entered.
Different constraints = Unique, check, default, not null, primary key, foreign key -constraints
Unique constraints = Specify indentity which column should not contain duplicated values
Check constraints = Limit the types of data a user can insert into the database
Not null constraints = ensures that data is entered into a cell, the cell can't be blank.
Primary key constraints = Uniquely indentifies each record in a database table, must contain unique values and it can't contain NULL values. Each table should have a primary key, and each table can have only one primary key.
Foreign key constraint = Points to a primary key in another table. Columns marked as foreign keys can contain null values.
self-reference = foreign key constraint to reference columns in the same table. When a self reference is used to query a table, this arrangement is now referenced as a self-join.
self-join = Self-reference
SSMS = SQL Server Management Studio. The central features is the Object Explorer.
XQuery = Is a query and functional programming language that is designed to query collections of XML data.
SQLCMD = is a command-line application that comes with Microsoft SQL Server and exposes the management features of SQL Server. t can also act as a scripting language to create and run a set of SQL statements as a script, stored as .sql files.
Transact-SQL = The primary means of programming and managing SQL Server. It exposes keywords so that you can create and manage databases and their components and monitor and manage the server itself. When you use SSMS to perform an action or task, you are executing Transact-SQL commands.
DML = Data Manipulation Language; INSERT, UPDATE, DELETE, MERGE
Each column --> attribute = ''
Each row --> record = ''
INSERT = Adds one or more new rows to a table or view in SQL Server.
UPDATE = Changes existing data in one or more columns in a table or view.
DELETE = Removes rows from a table or view.
MERGE = Performs insert, update or delete operations on a target table based on the results of a join with a source table.
DDL = Data Definition Language; it deals with creating database objects like tables, constraints, and stored procedures. DDL statements: USE, CREATE, ALTER, DROP in order to create and manage tables, user-defined data types, views, triggers, functions, and stored procedures.
USE = Changes the database context.
CREATE = Creates a SQL Server database object (table, view, or stored procedure).
ALTER = Changes an existing object.
DROP = Removes an object from the database.
TRUNCATE = Removes rows from a table and frees the space used by those rows.
DELETE = Remove rows from a table but does not free the space used by those rows removed.
ALTER = The ALTER statement changes an existing object; you can use it to add or remove columns from a table, as shown in the following example. You can also use ALTER to change the definition of a view, stored procedure, trigger, or function.
ALTER vs UPDATE = ALTER changes the object definition, UPDATE changes the data in the table.
DROP = he DROP statement actually removes an object from a database.
DROP vs DELETE = DROP removes an object from the database, DELETE deletes data from within a table.
DELETE = Delete rows from a table, but doesn't free the space containing the table.
TRUNCATE = Delete rows from a table, and free the space containing the table.
database object types = storage and programmability
object_type_storage = ''
object_type_programmability = ''
system tables = sys.Tables, sys.Columns, sys.Databases. sys.Constraints, sys.Views, sys.Procedures, sys.Indexes, sys.Triggers, sys.Objects.
data type = Numeric, Datetime
Numeric vs floats = The difference between a numeric data type and a float data type rests in whether you are using the data type for approximate numbers or fixed precision. A money or numeric data type is a fixed-precision data type because it must be represented with precision and scale.
Datetime = Is used to store date and time data in many different formats; datetime and datetime2.
Datetime vs Datetime2 = between the dates of January 1, 1753, and December 31, 9999, that are accurate to 3.33 milliseconds, you should use the datetime data type. In contrast, if you will be storing values between January 1, 1900, and June 6, 2079, that are accurate to only 1 minute, then datetime2 is the data type to use. The second important difference between the two data types is that the datetime data type uses 8 bytes of storage, whereas datetime2 only requires 4 bytes.
Integer = ""
Varchar = Used in databases where English attributes are supported, multiple languages uses the nvarchar data type. It minimizes issues with character conversion.
Boolean = Known as the bit data type; 8 bit --> 1 byte, 9/16 bits --> 2 bytes.
Floats = Numeric data type that's considered as an approximate-number data type. 4-byte float --> 7 digits precision, 8-byte floats --> 15 digits.
built-in data types = Exact and Approximate numbers, date and time, character strings, Unicode character strings, Binary strings, CLR and spatial data types.
Exact numbers = ''
Approximate numbers = ''
Date and time = ''
Character strings = ''
Unicode character strings = ''
Binary strings = ''
Other data types = ''
CLR data types = ''
Spatial data types = ''
exact_numerical_bit = 1 or 0, 1 byte
exact_numerical_tinyint = 0 to 255, 1 byte
exact_numerical_smallint = -2^15 -32768 to 2^15-1 32767, 2 bytes
exact_numerical_int = -2^31 to 2^31-1, 4 bytes
exact_numerical_bigint = -2^63 to 2^63-1, 8 bytes
exact_numerical_numeric = -11-^38+1 to 10^38-1, varies
exact_numerical_decimal = -10^38+1 to 10^38-1, varies
exact_numerical_smallmoney = -2147483648 to 2147483647, 4 bytes
exact_numerical_money = –922,337,203,685,477.508 to 922,337, 203,685,477.5807, 8 bytes
approximate_numerical_datetime = Based on a 24-hour clock, fractiomnal seconds, see Datetime, accuracy is .000 - .003 - .007, 8 bytes
approximate_numerical_smalldatetime = Based on a 24-hour day, no fractional seconds, accuracy is 1 minute, 4 bytes.
approximate_numerical_date = 0001-01-01 to 9999-12-31, 3 bytes
approximate_numerical_time = Based on a 24-hour clock, range is 00:00:00.0000000 through 23:59:59.9999999, accuracy is 100 nanoseconds, 5 bytes
approximate_numerical_datetimeoffset = Based on a 24 hours clock, 0001-01-01 - 9999-12-31, 10 bytes
approximate_numerical_datetime2 = Based on a 24 hours clock, 0001-01-01 - 9999-12-31, varies
Character_strings_char = Character data type with fixed length, varies.
Character_string_varchar = Character data type with variable length, varies.
Character_strings_text = Deprecated, uses varchar(max), varies.
Unicode_character_string_nchar = Character data type with fixed length, varies.
Unicode_character_string_nvarchar = Character data type with variable length, varies.
Unicode_character_string_ntext = Deprecated, use nvarchar(max) instead, varies.
Binary_strings_binary = Binary data with fixed length, varies.
Binary_strings_varbinary = Binary data with variable length, varies.
Binary_string_image = Deprecated, now uses varbinary(max), varies.
SQL_variant = Stores values of various SQL Server supported data types except text, ntext, image, timestamp and sql_variant, varies.
Uniqueidentifier = UUID; 16-byte GUID
Precendence = user-defined data types (highest), sql_variant, xml, datetimeoffset, datetime2, datetime, smalldatetime, date, time, float, real, decimal, money, smallmoney, bigint, int, smallint, tinyint, bit, ntext, text, image, timestamp, uniqueidentifier, nvarchar (including nvarchar(max) ), nchar, varchar (including varchar(max) ), char, varbinary (including varbinary(max) ), binary (lowest)
Collations = Mathematical or comparison function. A set of rules that determine how data is  sorted and compared. A collation clause can override how data is being sorted.
Precision = (p) is the maximal total number of decimal digits that can be stored both to the left and the right of the decimal point. A minimum of 1 and a maximum of 38, where the default precision number is 18.
scale = (s) reflects the maximum number of decimal digits that can be stored to the right of the decimal point. The value can be 0 through p, where the default scale is 0.
length = '' 
tinyint = ''
smallint = ''
int = The primary integer data type.
bigint = Used when the integer will exceed the int data datype.
bit = A Transact-SQL integer that takes a vlue of 1, 0 or NULL. True is 1 where False is 0.
Decimal, Numeric = Transact-SQL data types that have a fixed precision scale.
money = Transact-SQL data type that represents monetary or currency values, accuracy of 1/10000.
smallmoney = Transact-SQL data type.
real, float = Used in conjuction with floating-point numberic data.
Mantissa = The syntax of real is float(n), where n is the number of bits used to store the Mantissa of float number represented in scientific notation. The value of n must be between 1 and 53, where the default is 53. The Mantissa is the whole number and decimal part of a value, but not including the placeholders and exponents.
Date_Time_data_types = date, datetime, datetime2, datetimeoffset, smalldatetime, time.
DateTimeOffset = Similar to the DateTime data type, but it also keeps track of time zones. Based on a 24-hour clock, time-zone awareness.
SmallDateTime = Combines a date with a time of day, based on a 24-hour day and with seconds showing zero as (:00), fractional seconds are not provided.
Implicit conversion = When a conversion is done automatically. Float multiplied by an Integer will be expressed as a float.
Explicit conversion = Uses the CAST or CONVERT functions.
Cast and Convert function = Force a conversion. ANSI standards; import or export to other data ase management systems. cast(source-value AS destination-type). When n is not specified the default length is 30.
Convert_count_to_float = cast(coust as float) - CONVERT (data_type [ ( length ) ], expression [,style] )
When_n_not_specified_variable_declaration = Default length is 1.
Convert_specify_range_characters_digits_value = CONVERT(nvarchar(10), OrderDate, 101)
Unicode_literal = N'This is how a Unicode character string literal looks'
VAR_element = Preserves space in the row in which that element resides based on the column's defined size, and not on the actual number of characters in the character string itself, plus an extra two bytes of data for offset data. VARCHAR(25) supports a maximum of only 25 characters. Any data type withut the VAR element within it's name is a fixed length.
MAX_specifier = The default treshold is 8000. Specifying a value with a size greater than the default treshold will be stored external to the row identified as a LOB; large object.
nchar vs nvarchar = Use nchar when the sizes of the column data entries will be similar, use nvarchar when the sizes of the column data entries will vary considerably. Binary files, image files, SQL-variant, UUID.
char = A fixed-length non-Unicode character with n between 1 and 8000, char(n), length of bytes.
varchar = A non-Unicode data type varchar[(n|max)] between 1 and 8000.
Character_string_types = Regular; char, varchar, and Unicode; nvchar, nvarchar.
Database vs spreadsheets = A database can parse out redundant storage and information obtained from various relational spreadsheets.
view = A virtual table consisting of different columns from one or more tables, stored in a database as a query object. View is meant to be a security mechanism. Views allow you to limit the type of data users can access. View reduce complexity for end users so they don't have to learn how to write complex SQL queries.
Stored procedure = A SQL statement that has been stored or saved into a database. exec usp_sql_statement; user-created stored procedure.
Query analyzer = ''
SQL_injection = Anb attack in which malicious code is inserted into strings that are later passed on to instances of SQL Server waiting for parsing and execution.S
table = Providing structure for storing data within a relational database.
SQL_descriptor = ''
SELECT query = Retrieving columns, tables, using conditions.
Identifier = Separate the names with a commma, SQL treats a space as an identifier. If space is needed in a value, use square brackets or double quotes.
SELECT * = Everything.
WHERE clause = ''
Conjuction = AND, OR, NOT
BETWEEN = Specify the range to be used betweeb x and y.
Operators = <, >
UNION clause = Combine two or more queries into a single set, includes all the rows belonging to the query in that union. The number and order of the columns must be the same in each of the queries in the clause, and the date types must be compatible.
JOIN = Combine columns from tables, similar to EXCEPT and INTERSECT; give values from two separated table sources. Specified in either the FROM or the WHERE clause, but it's recommended to specify it in the FROM clause.
INNER JOIN = Match related records from different tables. Simplifies data retrieval.
OUTER JOIN = Can include not related records from one or both tables you're querying.
LEFT OUTER JOIN = Includes the statement from the INNER JOIN and the non-matching clause.
RIGHT OUTER JOIN = ''
FULL OUTER JOIN = ''
CROSS JOIN = Gives all rows from one table along with all rows from the other table with the WHERE condition.
SELF JOIN = Compare records from within the same table.
EXCEPT and INTERSECT = Return distinct values by comparing the result of two queries. EXCEPT gives the final result where data exist in the first query, and not in the second dataset. The INTERSECT gives the final result set where values in both of the queries match by the query on both the left and right sides of the operand. The number and order of the columns must be the same in all queries, and the data types must be compatible.
INSERT = Adding new row into a table.
UPDATE = Modify data stored in tables using data attributes.
DELETE = Delete one or more rows in a table or view.
TRUNCATE = Delete all rows, but leave the table structure in place.
DROP TABLE = Delete a table.
Referential integrity = Does not allow deletion of tables unless all of the related tables are deleted using a cascading delete
Cascading delete = If a record in the parent table is deleted, the corresponding record in the child table will automatically deleted.
TRAN = Transaction
BEGIN = ''
COMMIT = ''
ROLLBACK = ''
Normalization = A data design and organization process to eliminate redundant data to save space. Deviding a database into two or more tables and then defining table relationships.
First normalization form = 1NF; Eliminate repeating groups. No duplicated records, make use of primary key. No multivalued attributes. The entries in the column or attribute must be of the same data type.
Seconds normalization form = 2NF Eliminate redundant data. Each attribute describes the entity.
Third normalization form = 3NF; Eliminate columns not dependent on key. Every attribute must provide a fact about the key.
Normalization benefits = Reduced development costs and design time. Development cost, usability and extensibility.
Transitive dependency = Similar to a partial dependency in that they both refer to attributes that are not fully dependent on a primary key.
Candidate key = A column or set of columns that can be used as a unique key, the primary key. All potentional primary keys.
Primary key = An attribute or set of attributes that can be used to uniquely indentify each row. A primary key must be unique and must have a value that's not NULL. In attribute or set of attributes that can be used to uniquely identify each row. Without a primary key, it’s not a valid table. A primary key is a set of columns in a table that uniquely identifies each row of data.
Foreign key = Parent-child relationship. Referential integrity. To connect the two tables, the primary key is replicated from the primary to the secondary table, and all the key attributes duplicated from the primary table become known as the foreign key. Used to prevent actions that would destroy links between tables.
Composite key = A unique key that exists out of multiple columns in the same table. Define more than one column as the primary key.
Database categorized data types = Define and relate entitites.
Compound key = A unique key that exists out of multiple columns from different tables.
Unique key constaint = Acts similary to a primary key but columns containing a unique key constraint may contain only one row with NULL value; duplication value error. A table may have multi unique constraints.
Clustered index = Defines how SQL Server will sort the data stored inside the table, only one clustered index is allowed in each table. automatic creation of a clustered index when the primary key is defined for a table.
Non-clustered index = Non-clustered index key values, and each of those keys has a pointer to a data row that contains the key value. This pointer is referred to as a row locator, and the locator’s structure depends on whether the data pages are stored in a heap or as a clustered table.
Indexing = The only real drawbacks to indexing are the time it takes to build the actual indexes and the storage space the indexes require.
Index = an on-disk (or stored) structure associated entirely with a table or a view that increases the speed of data retrieval. In order to create an index, a series of keys is built from one or more columns in each row within a table or a view. These keys are then stored in a structure called a B-tree that enables SQL Server to find the row(s) associated with those defined values much more quickly and efficiently.
B-tree = ''"""

import random as rnd

chapter1_splitted_on_newline = chapter1.split("\n")

lst_data = []
for line in chapter1_splitted_on_newline:
    lst_data.append(line.split("="))

keys = []
values = []
for data in lst_data:
    keys.append(data[0].lstrip().rstrip())
    values.append(data[1].lstrip().rstrip())
    # print(data[1])
    
dct = {keys[i]: values[i] for i in range(len(values))}

def questions(dictionary, question):
    return dct.get(question)

random_term = rnd.choice(keys)
term_defined = questions(dct, random_term)
print(f"Term: {random_term}\nAnswer: {term_defined}")
